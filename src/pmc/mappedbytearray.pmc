/*
Copyright (C) 2010, Parrot Foundation.

=head1 NAME

src/pmc/mappedbytearray.pmc - Mapped byte array

=head1 DESCRIPTION

A memory mapped file or shared memory segment accesible as array of bytes.

Bare minimal functionality available, only for posix platforms
(tested on linux).

=cut

*/

#include "parrot/parrot.h"
#include "../src/io/io_private.h"

#define CAN_READ  1
#define CAN_WRITE 2

#ifdef PARROT_HAS_HEADER_SYSMMAN
#    include <sys/mman.h>
#    define ENABLED
#endif

/* HEADERIZER HFILE: none */
/* HEADERIZER BEGIN: static */
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */

PARROT_CAN_RETURN_NULL
static void * mapfromfilehandle(
    PIOHANDLE handle,
    unsigned long size,
    int flag);

PARROT_CAN_RETURN_NULL
static void * mapfromfilename(PARROT_INTERP,
    ARGIN(STRING *name),
    ARGMOD(unsigned long *size),
    int flag)
        __attribute__nonnull__(1)
        __attribute__nonnull__(2)
        __attribute__nonnull__(3)
        FUNC_MODIFIES(*size);

PARROT_DOES_NOT_RETURN
static void unavailable(PARROT_INTERP, ARGIN(const char *msg))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

#define ASSERT_ARGS_mapfromfilehandle __attribute__unused__ int _ASSERT_ARGS_CHECK = (0)
#define ASSERT_ARGS_mapfromfilename __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(name) \
    , PARROT_ASSERT_ARG(size))
#define ASSERT_ARGS_unavailable __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(msg))
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */
/* HEADERIZER END: static */

pmclass MappedByteArray auto_attrs {
    ATTR unsigned char *buffer;
    ATTR UINTVAL size;

/*

=head2 Vtable Functions

=over 4

=item C<init()>

Initialize without doing any mapping.

=item C<init_pmc(PMC *init)>

The argument must be a String PMC with a file name. Maps the whole file.

Other options still not available.

=item C<destroy()>

Free all resources used.

=cut

*/

    VTABLE void init() {
        #ifdef ENABLED
        PObj_custom_destroy_SET(SELF);
        #endif
    }

    VTABLE void init_pmc(PMC * init) {
        #ifdef ENABLED
        PObj_custom_destroy_SET(SELF);
        if (VTABLE_isa(INTERP, init, CONST_STRING(INTERP, "String"))) {
            unsigned long length = 0;
            STRING *name = VTABLE_get_string(INTERP, init);
            void *mapping = mapfromfilename(interp, name, &length, CAN_READ);
            if (mapping == 0 || mapping == (void *)-1)
                Parrot_ex_throw_from_c_args(INTERP, NULL,
                        EXCEPTION_INVALID_OPERATION,
                        "mmap failed: %s", strerror(errno));
            PObj_custom_destroy_SET(SELF);
            SET_ATTR_size(INTERP, SELF, length);
            SET_ATTR_buffer(INTERP, SELF, (unsigned char*)mapping);
        }
        else {
            unavailable(INTERP, "*feature unknown or not implemented yet*");
        }
        #else
        unavailable(INTERP, "MappedByteArray");
        #endif
    }

    VTABLE void destroy() {
        #ifdef ENABLED
        unsigned char *buffer;
        UINTVAL size;
        GET_ATTR_size(INTERP, SELF, size);
        GET_ATTR_buffer(INTERP, SELF, buffer);
        if (size > 0) {
            munmap(buffer, size);
        }
        #endif
    }

/*

=item C<get_bool()>

Return true if active, false otherwise.

=cut

*/

    VTABLE INTVAL get_bool() {
        #ifdef ENABLED
        unsigned char *buffer;
        GET_ATTR_buffer(INTERP, SELF, buffer);
        return buffer != NULL;
        #else
        return 0;
        #endif
    }


/*

=item C<elements()>

Return the size of the mapped area.

=cut

*/

    VTABLE INTVAL elements() {
        #ifdef ENABLED
        UINTVAL size;
        GET_ATTR_size(INTERP, SELF, size);
        return size;
        #else
        return 0;
        #endif
    }


/*

=item C<get_integer_keyed_int(INTVAL pos)>

Get the byte at pos.

=item C<set_integer_keyed_int(INTVAL pos, INTVAL value)>

Set the byte at pos to value.

=cut

*/

    VTABLE INTVAL get_integer_keyed_int(INTVAL pos) {
        INTVAL size;
        unsigned char *buffer;
        GET_ATTR_size(INTERP, SELF, size);
        if (size <= 0)
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_INVALID_OPERATION,
                    "not mapped");
        if (pos < 0 || pos >= size)
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_OUT_OF_BOUNDS,
                    "index out of mapped");
        GET_ATTR_buffer(INTERP, SELF, buffer);
        return buffer[pos];
    }

    VTABLE void set_integer_keyed_int(INTVAL pos, INTVAL value) {
        INTVAL size;
        unsigned char *buffer;
        GET_ATTR_size(INTERP, SELF, size);
        if (size <= 0)
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_INVALID_OPERATION,
                    "not mapped");
        if (pos < 0 || pos >= size)
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_OUT_OF_BOUNDS,
                    "index out of mapped");
        GET_ATTR_buffer(INTERP, SELF, buffer);
        buffer[pos] = value;
    }


/*

=back

=head2 Methods

=over 4

=item C<supported()>

Return 0 if file mapping is not supported, non zero otherwise.

=cut

*/

    METHOD supported()
    {
        #ifdef ENABLED
        RETURN(INTVAL 1);
        #else
        RETURN(INTVAL 0);
        #endif
    }

/*

=item C<open(STRING *filename, STRING *mode :optional)>

Map a file by its name. The mode argument can be "r", "w" or "rw",
"r" is assumed if omitted.

=cut

*/

    METHOD open(STRING *filename, STRING *mode :optional)
    {
        #ifdef ENABLED
        unsigned long length = 0;
        int flag = 0;
        void *mapping;
        if (STRING_IS_NULL(mode))
            flag = CAN_READ;
        else {
            INTVAL len = Parrot_str_length(INTERP, mode);
            INTVAL i;
            for (i = 0; i < len; ++i) {
                switch (STRING_ord(INTERP, mode, i)) {
                  case 'r':
                    flag |= CAN_READ;
                    break;
                  case 'w':
                    flag |= CAN_WRITE;
                    break;
                  default:
                    Parrot_ex_throw_from_c_args(INTERP, NULL,
                            EXCEPTION_INVALID_OPERATION,
                            "invalid open mapped mode");
                }
            }
        }
        mapping = mapfromfilename(interp, filename, &length, flag);
        if (mapping == 0 || mapping == (void *)-1)
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_INVALID_OPERATION,
                    "mmap failed: %s", strerror(errno));
        SET_ATTR_size(INTERP, SELF, length);
        SET_ATTR_buffer(INTERP, SELF, (unsigned char*)mapping);
        #endif
        RETURN(void);
    }

/*

=item C<close()>

Close the mapping. Return 0 if the mapping was opened aand the unmap operation
does not fail, non zero otherwise.

=cut

*/

    METHOD close()
    {
        INTVAL result = 1;
        #ifdef ENABLED
        unsigned char *buffer;
        GET_ATTR_buffer(INTERP, SELF, buffer);
        if (buffer) {
            INTVAL size;
            GET_ATTR_size(INTERP, SELF, size);
            result = munmap(buffer, size);
            if (result == 0) {
                buffer = NULL;
                SET_ATTR_buffer(INTERP, SELF, buffer);
                SET_ATTR_size(INTERP, SELF, 0);
            }
        }
        #endif
        RETURN(INTVAL result);
    }

} /* pmclass end */

/*

=back

=head2 Helper functions

=over 4

=item C<static void unavailable(PARROT_INTERP, const char *msg)>

Throws appropiately for functionality not available in the current platform.

=item C<static void * mapfromfilehandle(PIOHANDLE handle, unsigned long size,
int flag)>

Maps a file by its OS handle.

=item C<static void * mapfromfilename(PARROT_INTERP, STRING *name, unsigned long
*size, int flag)>

Maps a file by its filename, throw if the file can't be opened.

=cut

*/

PARROT_DOES_NOT_RETURN
static void
unavailable(PARROT_INTERP, ARGIN(const char *msg))
{
    Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_UNIMPLEMENTED,
            "%s not implemented in this platform", msg);
}

PARROT_CAN_RETURN_NULL
static void *
mapfromfilehandle(PIOHANDLE handle, unsigned long size, int flag)
{
    #ifdef ENABLED
    int prot = 0;
    if (flag & CAN_READ) prot |= PROT_READ;
    if (flag & CAN_WRITE) prot |= PROT_WRITE;
    return mmap(0, size, prot, MAP_SHARED, handle, 0);
    #else
    return (void *)-1;
    #endif
}

PARROT_CAN_RETURN_NULL
static void *
mapfromfilename(PARROT_INTERP, ARGIN(STRING *name), ARGMOD(unsigned long *size), int flag)
{
    void *mapping;
    #ifdef ENABLED
    int handle;
    {
        char * name_str = Parrot_str_to_cstring(interp, name);
        int openmode = 0;
        switch (flag & (CAN_READ | CAN_WRITE)) {
          case CAN_READ:
            openmode = O_RDONLY;
            break;
          case CAN_READ | CAN_WRITE:
          case CAN_WRITE:
            openmode = O_RDWR;
            break;
          default:
            /* Should never happen, invalid modes must be caught before
             * calling this function.
             */
            Parrot_ex_throw_from_c_args(interp, NULL,
                EXCEPTION_INTERNAL_NOT_IMPLEMENTED, "invalid mmap mode");
        }
        handle = open(name_str, openmode);
        Parrot_str_free_cstring(name_str);
    }
    if (handle == -1)
        Parrot_ex_throw_from_c_args(interp, NULL,
                EXCEPTION_INVALID_OPERATION, "cannot open file '%Ss'", name);
    if (*size == 0)
        *size = lseek(handle, 0, SEEK_END);
    mapping = mapfromfilehandle(handle, *size, flag);

    #else
    mapping = (void *)-1;
    #endif

    return mapping;
}

/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
