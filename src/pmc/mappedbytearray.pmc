/*
Copyright (C) 2010, Parrot Foundation.

=head1 NAME

src/pmc/mappedbytearray.pmc - Mapped byte array

=head1 DESCRIPTION

A memory mapped file or shared memory segment accesible as array of bytes.

Bare minimal functionality available, only for posix platforms
(tested on linux).

=cut

*/

#include "parrot/parrot.h"
#include "../src/io/io_private.h"

#define CAN_READ  1
#define CAN_WRITE 2

#ifdef PARROT_HAS_HEADER_SYSMMAN
#    include <sys/mman.h>
#    define ENABLED
#endif

/* HEADERIZER HFILE: none */
/* HEADERIZER BEGIN: static */
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */

PARROT_DOES_NOT_RETURN
static void unavailable(PARROT_INTERP, ARGIN(const char *msg))
        __attribute__nonnull__(1)
        __attribute__nonnull__(2);

#define ASSERT_ARGS_unavailable __attribute__unused__ int _ASSERT_ARGS_CHECK = (\
       PARROT_ASSERT_ARG(interp) \
    , PARROT_ASSERT_ARG(msg))
/* Don't modify between HEADERIZER BEGIN / HEADERIZER END.  Your changes will be lost. */
/* HEADERIZER END: static */

PARROT_CAN_RETURN_NULL
static void *
mapfromfilehandle(PIOHANDLE handle, unsigned long size, int flag)
{
    int prot = 0;
    if (flag & CAN_READ) prot |= PROT_READ;
    if (flag & CAN_WRITE) prot |= PROT_WRITE;
    return mmap(0, size, prot, MAP_SHARED, handle, 0);
}

PARROT_CAN_RETURN_NULL
static void *
mapfromfilename(PARROT_INTERP, ARGIN(STRING *name), unsigned long *size, int flag)
{
    int handle;
    void *mapping;
    {
        char * name_str = Parrot_str_to_cstring(interp, name);
        int openmode = 0;
        switch (flag & (CAN_READ | CAN_WRITE)) {
          case CAN_READ:
            openmode = O_RDONLY;
            break;
          case CAN_READ | CAN_WRITE:
          case CAN_WRITE:
            openmode = O_RDWR;
            break;
          default:
            /* Should never happen, invalid modes must be caught before
             * calling this function.
             */
            Parrot_ex_throw_from_c_args(interp, NULL,
                EXCEPTION_INTERNAL_NOT_IMPLEMENTED, "invalid mmap mode");
        }
        handle = open(name_str, openmode);
        Parrot_str_free_cstring(name_str);
    }
    if (handle == -1)
        Parrot_ex_throw_from_c_args(interp, NULL,
                EXCEPTION_INVALID_OPERATION, "cannot open file '%Ss'", name);
    if (*size == 0)
        *size = lseek(handle, 0, SEEK_END);
    mapping = mapfromfilehandle(handle, *size, flag);
    return mapping;
}

pmclass MappedByteArray auto_attrs {
    ATTR unsigned char *buffer;
    ATTR UINTVAL size;

/*

=head2 Vtable Functions

=over 4

=item C<init_pmc>

The argument must be a String PMC with a file name. Maps the whole file.

Other options still not available.

=item C<destroy>

Free all resources used.

=cut

*/

    VTABLE void init_pmc(PMC * init) {
        #ifdef ENABLED
        if (VTABLE_isa(INTERP, init, CONST_STRING(INTERP, "String"))) {
            unsigned long length = 0;
            STRING *name = VTABLE_get_string(INTERP, init);
            void *mapping = mapfromfilename(interp, name, &length, CAN_READ);
            if (mapping == 0 || mapping == (void *)-1)
                Parrot_ex_throw_from_c_args(INTERP, NULL,
                        EXCEPTION_INVALID_OPERATION,
                        "mmap failed: %s", strerror(errno));
            PObj_custom_destroy_SET(SELF);
            SET_ATTR_size(INTERP, SELF, length);
            SET_ATTR_buffer(INTERP, SELF, (unsigned char*)mapping);
        }
        else {
            unavailable(INTERP, "*feature unknown or not implemented yet*");
        }
        #else
        unavailable(INTERP, "MappedByteArray");
        #endif
    }

    VTABLE void destroy() {
        #ifdef ENABLED
        unsigned char *buffer;
        UINTVAL size;
        GET_ATTR_size(INTERP, SELF, size);
        GET_ATTR_buffer(INTERP, SELF, buffer);
        if (size > 0) {
            munmap(buffer, size);
        }
        #endif
    }

/*

=item C<elements>

Return the size of the mapped area.

=cut

*/

    VTABLE INTVAL elements() {
        UINTVAL size;
        GET_ATTR_size(INTERP, SELF, size);
        return size;
    }


/*

=item C<get_integer_keyed_int>

Get a byte.

=cut

*/

    VTABLE INTVAL get_integer_keyed_int(INTVAL pos) {
        INTVAL size;
        unsigned char *buffer;
        GET_ATTR_size(INTERP, SELF, size);
        if (size <= 0)
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_INVALID_OPERATION,
                    "not mapped");
        if (pos < 0 || pos >= size)
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_OUT_OF_BOUNDS,
                    "index out of mapped");
        GET_ATTR_buffer(INTERP, SELF, buffer);
        return buffer[pos];
    }

    VTABLE void set_integer_keyed_int(INTVAL pos, INTVAL value) {
        INTVAL size;
        unsigned char *buffer;
        GET_ATTR_size(INTERP, SELF, size);
        if (size <= 0)
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_INVALID_OPERATION,
                    "not mapped");
        if (pos < 0 || pos >= size)
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_OUT_OF_BOUNDS,
                    "index out of mapped");
        GET_ATTR_buffer(INTERP, SELF, buffer);
        buffer[pos] = value;
    }


/*

=back

=cut

*/

    METHOD open(STRING *filename, STRING *mode :optional)
    {
        unsigned long length = 0;
        int flag = 0;
        void *mapping;
        if (STRING_IS_NULL(mode))
            flag = CAN_READ;
        else {
            INTVAL len = Parrot_str_length(INTERP, mode);
            INTVAL i;
            for (i = 0; i < len; ++i) {
                switch (STRING_ord(INTERP, mode, i)) {
                  case 'r':
                    flag |= CAN_READ;
                    break;
                  case 'w':
                    flag |= CAN_WRITE;
                    break;
                  default:
                    Parrot_ex_throw_from_c_args(INTERP, NULL,
                            EXCEPTION_INVALID_OPERATION,
                            "invalid open mapped mode");
                }
            }
        }
        mapping = mapfromfilename(interp, filename, &length, flag);
        if (mapping == 0 || mapping == (void *)-1)
            Parrot_ex_throw_from_c_args(INTERP, NULL,
                    EXCEPTION_INVALID_OPERATION,
                    "mmap failed: %s", strerror(errno));
        PObj_custom_destroy_SET(SELF);
        SET_ATTR_size(INTERP, SELF, length);
        SET_ATTR_buffer(INTERP, SELF, (unsigned char*)mapping);
        RETURN(void);
    }

} /* pmclass end */

/*

=head2 Helper functions

=over 4

=item unavailable()

Throws appropiately for functionality not available in the current platform.

=cut

*/

PARROT_DOES_NOT_RETURN
static void
unavailable(PARROT_INTERP, ARGIN(const char *msg))
{
    Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_UNIMPLEMENTED,
            "%s not implemented in this platform", msg);
}

/*

=back

=cut

*/

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
